import { Engine } from './engines/Engine';
export interface RouteContext {
    path: string;
    set: (key: string, value: any) => void;
    [prop: string]: any;
}
export interface Request {
    get: (k: string, def?: string) => string | null | undefined;
    path: string;
    params: {
        [k: string]: string;
    };
    splats: string[];
    query: {
        [k: string]: string;
    };
    stop: () => void;
    isStopped: () => boolean;
}
export declare type RouteCallback = (req: Request, ctx: RouteContext) => void | Promise<void>;
export declare type AlwaysCallback = (ctx: RouteContext) => void | Promise<void>;
export declare type ErrorCallback = (e: Error, context: RouteContext) => void | Promise<void>;
export interface Router {
    get: (path: string | RegExp, callback: RouteCallback) => Router;
    exit: (path: string | RegExp, callback: RouteCallback) => Router;
    always: (callback: AlwaysCallback) => Router;
    error: (errorCode: number | '*', callback: ErrorCallback) => Router;
    navigate: (path: string) => void;
    /**
     * Go to a specific page in the history
     * @param {Number} relative Relative position from the current page which is 0
     */
    go: (n?: number) => void;
    /**
     * Go back in the history
     */
    back: () => void;
    /**
     * GO forward in the history
     */
    forward: () => void;
    setLocation: (path: string) => void;
    run: (path?: string) => Router;
    teardown: () => Router;
    buildUrl: (path: string) => string;
    _getOptions: () => Omit<RouterOptions, 'engine'>;
}
export interface RouterOptions {
    engine?: () => Engine;
    ignoreCase?: boolean;
    basePath?: string;
}
export declare type RouterFactoryType = (options?: RouterOptions) => Router;
declare const createRouter: RouterFactoryType;
export default createRouter;
